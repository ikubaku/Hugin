use std::error::Error;
use std::fs::File;
use std::io::Read;
use std::path::{PathBuf, Path};
use std::str::FromStr;

use clap::clap_app;
use flexi_logger::{Duplicate, LevelFilter, LogSpecBuilder, LogSpecification, Logger};
use log::{debug, error, info, trace, warn};

mod config;
mod error;
mod job;
mod session;
mod runner;
mod clone_pair;

use crate::config::ccfindersw::CCFinderSWConfig;
use crate::config::Config;
use crate::error::NoValidConfigurationError;
use crate::job::Job;
use crate::session::Session;
use crate::runner::ccfindersw::CCFinderSWRunner;
use crate::runner::Runner;
use crate::clone_pair::ClonePair;

fn main() -> Result<(), Box<dyn Error>> {
    // Parse options
    let matches = clap_app!(Hugin =>
        (version: "0.1.0")
        (author: "ikubaku <hide4d51@gmail.com")
        (about: "An Arduino Project code cloning detector: Job dispatcher module")
        (@arg CONFIG: -c --config +takes_value "configuration filename")
        (@arg LOG: -l --log "enable logging to file")
        (@arg verbose: -v --verbose ... "verbosity of the logging (max stack: 2)")
        (@arg no_warning: -q --no_warn "suppress warning message (note that verbosity option overrides this)")
        (@arg SESSION: +required "the Hugin session generated by Munin")
    ).get_matches();

    // Initialize logger
    let mut log_spec_builder = LogSpecBuilder::new();
    log_spec_builder.default(LevelFilter::Warn);
    log_spec_builder.insert_modules_from(LogSpecification::env().unwrap_or_else(|e| {
        panic!(
            "Something went wrong while parsing RUST_LOG environmental variable: {:?}",
            e
        )
    }));
    if matches.is_present("no_warning") {
        log_spec_builder.default(LevelFilter::Error);
    }
    match matches.occurrences_of("verbose") {
        0 => {}
        1 => {
            log_spec_builder.default(LevelFilter::Info);
            ()
        }
        2 => {
            log_spec_builder.default(LevelFilter::Debug);
            ()
        }
        _ => panic!("Invalid verbosity was specified(maybe too much switches?)."),
    };
    let log_spec = log_spec_builder.build();
    let logger = Logger::with(log_spec).duplicate_to_stderr(Duplicate::Error);
    let logger = if matches.is_present("LOG") {
        println!("Enabled logging to the log file.");
        logger.log_to_file()
    } else {
        logger
    };
    logger.start()?;

    info!("Started the logger.");

    // Load configuration
    let config: Option<Config>;
    if let Some(filename) = matches.value_of("CONFIG") {
        info!("Loading configuration from file: {}...", filename);
        let mut file = File::open(filename)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        config = Some(toml::from_str(contents.as_str())?);
        println!(
            "Munin database directory: {}", shellexpand::tilde(
                config
                .clone()
                .unwrap()
                .munin_database_root
                .to_str()
                .unwrap()
            )
        );
    } else {
        info!("Using the default configuration.");
        config = None;
    }

    // Load session
    let session_path = PathBuf::from_str(matches.value_of("SESSION").unwrap())?;
    let session: Session;
    {
        info!("Loading session...");
        let mut filename = session_path.clone();
        filename.push(matches.value_of("SESSION").unwrap());
        filename.push("session.toml");
        let mut file = File::open(filename)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        session = toml::from_str(contents.as_str())?;
        info!(
            "The project path is: {}",
            session.project_path.to_str().unwrap()
        );
        info!("The jobs path is: {}", session.jobs_path.to_str().unwrap());
    }

    // Load jobs
    let mut jobs = Vec::new();
    for job_file in session_path
        .canonicalize()?
        .join(session.jobs_path.as_path())
        .read_dir()?
    {
        debug!("job_file: {:?}", job_file);
        let path = session.jobs_path.join(job_file?.path());
        let mut file = File::open(path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        let job: Job = toml::from_str(contents.as_str())?;
        println!("Found job: {:?}", job);
        jobs.push(job);
    }

    match config {
        None => {
            let config = Config::default();
            let ccfindersw_config = CCFinderSWConfig::try_from_config(&config).unwrap();

            let project_path = session_path.join(&session.project_path);
            let runner = CCFinderSWRunner::create(ccfindersw_config, &project_path, &Path::new(shellexpand::tilde(&config.munin_database_root.to_str().unwrap()).as_ref()));
            for j in jobs {
                match runner.run_job(j) {
                    Ok(res) => {
                        info!("Result: {:?}", res);
                    }
                    Err(e) => {
                        error!("Job failed with error: {:?}", e);
                    }
                }
            }
        }
        Some(config) => {
            let ccfindersw_config = CCFinderSWConfig::try_from_config(&config).ok_or_else(|| {
                error!("No valid configuration.");
                NoValidConfigurationError
            })?;
            println!("CCFinderSW configuration: {:?}", ccfindersw_config);

            let project_path = session_path.canonicalize()?.join(&session.project_path);
            let runner = CCFinderSWRunner::create(ccfindersw_config, &project_path, &Path::new(shellexpand::tilde(&config.munin_database_root.to_str().unwrap()).as_ref()));
            for j in jobs {
                match runner.run_job(j) {
                    Ok(res) => {
                        info!("Result: {:?}", res);
                    }
                    Err(e) => {
                        error!("Job failed with error: {:?}", e);
                    }
                }
            }
        }
    }

    println!("Hello, world!");
    info!("Exiting...");

    Ok(())
}
