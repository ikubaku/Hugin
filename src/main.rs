use std::error::Error;
use std::fs::File;
use std::io::{Read, Write};
use std::path::PathBuf;
use std::str::FromStr;
use std::thread;
use std::thread::JoinHandle;
use std::sync::Arc;

use clap::clap_app;

use flexi_logger::{Duplicate, LevelFilter, LogSpecBuilder, LogSpecification, Logger};

use log::{debug, error, info, warn};

use num_integer::div_ceil;

use indicatif::{MultiProgress, ProgressBar, ProgressStyle};

mod clone_pair;
mod config;
mod error;
mod job;
mod runner;
mod session;

use crate::config::ccfindersw::CCFinderSWConfig;
use crate::config::Config;
use crate::error::NoValidConfigurationError;
use crate::job::{Job, JobResult, JobResults};
use crate::runner::ccfindersw::CCFinderSWRunner;
use crate::runner::Runner;
use crate::session::Session;

fn run_jobs<R>(jobs: Arc<Vec<Job>>, runner: Arc<R>, number_of_threads: usize) -> Vec<JobResult>
where R: Runner + Sync + Send + 'static,
{
    let mut results = Vec::new();
    let divided_jobs = jobs.chunks(div_ceil(jobs.len(), number_of_threads));
    if divided_jobs.len() != number_of_threads {
        error!("BUG: Could not divide the job to the required number of parts.");
    }
    info!("Running detector on {} thread(s)...", divided_jobs.len());
    let m = MultiProgress::new();
    let style = ProgressStyle::default_bar()
        .template("PROGRESS: {wide_bar} {pos}/{len}")
        .progress_chars("##-");
    let threads = divided_jobs.map(|thread_jobs| {
        let bar = m.add(ProgressBar::new(thread_jobs.len() as u64));
        bar.set_style(style.clone());
        let runner = runner.clone();
        let mut temp = Vec::new();
        temp.extend_from_slice(thread_jobs);
        let thread_jobs = temp;
        thread::spawn(move || {
            let mut thread_results = Vec::new();
            for j in thread_jobs {
                bar.inc(1);
                match runner.run_job(j.clone()) {
                    Ok(res) => {
                        let job_result = j.create_result(res);
                        thread_results.push(job_result);
                    }
                    Err(e) => {
                        error!("Job failed with error: {:?}", e);
                    }
                }
            }
            bar.finish();
            thread_results
        })
    }).collect::<Vec<JoinHandle<Vec<JobResult>>>>();

    m.join().unwrap();
    for t in threads {
        match t.join() {
            Ok(res) => {
                let mut temp = Vec::new();
                temp.extend(res);
                results.append(&mut temp);
            }
            Err(e) => {
                error!("A thread failed with error: {:?}", e);
            }
        }
    }

    results
}

fn main() -> Result<(), Box<dyn Error>> {
    // Parse options
    let matches = clap_app!(Hugin =>
        (version: "0.1.0")
        (author: "ikubaku <hide4d51@gmail.com")
        (about: "An Arduino Project code cloning detector: Job dispatcher module")
        (@arg CONFIG: -c --config +takes_value "configuration filename")
        (@arg LOG: -l --log "enable logging to file")
        (@arg verbose: -v --verbose ... "verbosity of the logging (max stack: 2)")
        (@arg no_warning: -q --no_warn "suppress warning message (note that verbosity option overrides this)")
        (@arg SESSION: +required "the Hugin session generated by Munin")
        (@arg OUTPUT: +required "the output file name for the result")
    ).get_matches();

    // Initialize logger
    let mut log_spec_builder = LogSpecBuilder::new();
    log_spec_builder.default(LevelFilter::Warn);
    log_spec_builder.insert_modules_from(LogSpecification::env().unwrap_or_else(|e| {
        panic!(
            "Something went wrong while parsing RUST_LOG environmental variable: {:?}",
            e
        )
    }));
    if matches.is_present("no_warning") {
        log_spec_builder.default(LevelFilter::Error);
    }
    match matches.occurrences_of("verbose") {
        0 => {}
        1 => {
            log_spec_builder.default(LevelFilter::Info);
            ()
        }
        2 => {
            log_spec_builder.default(LevelFilter::Debug);
            ()
        }
        _ => panic!("Invalid verbosity was specified(maybe too much switches?)."),
    };
    let log_spec = log_spec_builder.build();
    // FIXME: Need better error reports.
    //let logger = Logger::with(log_spec).duplicate_to_stderr(Duplicate::Error);
    let logger = Logger::with(log_spec);
    let logger = if matches.is_present("LOG") {
        println!("Enabled logging to the log file.");
        logger.log_to_file()
    } else {
        logger
    };
    logger.start()?;

    info!("Started the logger.");

    // Load configuration
    let config: Option<Config>;
    if let Some(filename) = matches.value_of("CONFIG") {
        info!("Loading configuration from file: {}...", filename);
        let mut file = File::open(filename)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        config = Some(toml::from_str(contents.as_str())?);
        println!(
            "Munin database directory: {}",
            config
                .clone()
                .unwrap()
                .get_absolute_database_root_path()?
                .to_str()
                .unwrap(),
        );
    } else {
        info!("Using the default configuration.");
        config = None;
    }

    // Secure the output path
    let output_filename = PathBuf::from_str(matches.value_of("OUTPUT").unwrap())?;
    let mut output_file = File::create(output_filename)?;

    // Load session
    let session_path = PathBuf::from_str(matches.value_of("SESSION").unwrap())?;
    let session: Session;
    {
        info!("Loading session...");
        let mut filename = session_path.clone();
        filename.push(matches.value_of("SESSION").unwrap());
        filename.push("session.toml");
        let mut file = File::open(filename)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        session = toml::from_str(contents.as_str())?;
        info!(
            "The project path is: {}",
            session
                .get_absolute_project_path(&session_path)?
                .to_str()
                .unwrap(),
        );
        info!(
            "The jobs path is: {}",
            session
                .get_absolute_jobs_path(&session_path)?
                .to_str()
                .unwrap()
        );
    }

    // Load jobs
    let mut jobs = Vec::new();
    for job_file in session.get_absolute_jobs_path(&session_path)?.read_dir()? {
        debug!("job_file: {:?}", job_file);
        let path = session
            .get_absolute_jobs_path(&session_path)?
            .join(job_file?.path());
        let mut file = File::open(path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        let job: Job = toml::from_str(contents.as_str())?;
        println!("Found job: {:?}", job);
        jobs.push(job);
    }

    match config {
        None => {
            let config = Config::default();
            let number_of_jobs = config.number_of_jobs;
            let ccfindersw_config = CCFinderSWConfig::try_from_config(&config).unwrap();

            let project_path = session.get_absolute_project_path(&session_path)?;
            let runner = CCFinderSWRunner::create(
                ccfindersw_config,
                &project_path,
                &config.get_absolute_database_root_path()?,
            );

            let results = run_jobs(Arc::new(jobs), Arc::new(runner), number_of_jobs);

            let results = JobResults {
                results,
            };

            let mut content = String::new();
            content = toml::to_string(&results)?;
            write!(output_file, "{}", content)?;
        }
        Some(config) => {
            let number_of_jobs = config.number_of_jobs;
            let ccfindersw_config =
                CCFinderSWConfig::try_from_config(&config).ok_or_else(|| {
                    error!("No valid configuration.");
                    NoValidConfigurationError
                })?;
            println!("CCFinderSW configuration: {:?}", ccfindersw_config);

            let project_path = session.get_absolute_project_path(&session_path)?;
            let runner = CCFinderSWRunner::create(
                ccfindersw_config,
                &project_path,
                &config.get_absolute_database_root_path()?,
            );

            let results = run_jobs(Arc::new(jobs), Arc::new(runner), number_of_jobs);

            let results = JobResults {
                results,
            };

            let mut content = String::new();
            content = toml::to_string(&results)?;
            write!(output_file, "{}", content)?;
        }
    }

    info!("Exiting...");

    Ok(())
}
